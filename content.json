{"meta":{"title":"刘沅的博客","subtitle":null,"description":null,"author":"Liu Yuan","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"解决0.1+0.2=0.3000000000004问题","slug":"0.1+0.2问题","date":"2018-06-04T01:03:38.175Z","updated":"2018-06-04T01:04:33.315Z","comments":true,"path":"2018/06/04/0.1+0.2问题/","link":"","permalink":"http://yoursite.com/2018/06/04/0.1+0.2问题/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"vue2.0使用swiper组件实现轮播","slug":"vueSwiper","date":"2018-05-15T12:18:27.561Z","updated":"2018-05-15T13:09:38.157Z","comments":true,"path":"2018/05/15/vueSwiper/","link":"","permalink":"http://yoursite.com/2018/05/15/vueSwiper/","excerpt":"","text":"Swiper(Swiper master)是目前应用较广泛的移动端网页触摸内容滑动js插件。基于 Swiper4、适用于 Vue 的轮播组件，支持服务端渲染和单页应用。如果需要回退到 Swiper3，请使用 v2.6.7 版本。 Vue-Awesome-Swiper安装swiper1npm install vue-awesome-swiper --save 调用 在main.js中引用swiper12345 import Vue from &apos;vue&apos; import VueAwesomeSwiper from &apos;vue-awesome-swiper&apos;// 导入swiper样式 import &apos;swiper/dist/css/swiper.css&apos; Vue.use(VueAwesomeSwiper) 在组件中使用swiper插件1234567891011// 导入样式import &apos;swiper/dist/css/swiper.css&apos;// 导入swiperimport &#123; swiper , swiperSlide &#125; from &apos;vue-awesome-swiper&apos;//注册组件export default&#123; components:&#123; swiper, swiperSlide &#125;&#125; 异步数据请求 example123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;swiper :options=&quot;swiperOption&quot;&gt; &lt;swiper-slide v-for=&quot;(slide, index) in swiperSlides&quot; :key=&quot;index&quot;&gt;I&apos;m Slide &#123;&#123; slide &#125;&#125;&lt;/swiper-slide&gt; &lt;div class=&quot;swiper-pagination&quot; slot=&quot;pagination&quot;&gt;&lt;/div&gt; &lt;/swiper&gt;&lt;/template&gt;&lt;script&gt; // 导入样式 import &apos;swiper/dist/css/swiper.css&apos; // 导入swiper import &#123; swiper , swiperSlide &#125; from &apos;vue-awesome-swiper&apos; export default &#123; name: &apos;carrousel&apos;, data() &#123; return &#123; swiperOption: &#123; pagination: &#123; el: &apos;.swiper-pagination&apos; &#125; &#125;, swiperSlides: [1, 2, 3, 4, 5] &#125; &#125;, mounted() &#123; setInterval(() =&gt; &#123; if (this.swiperSlides.length &lt; 10) &#123; this.swiperSlides.push(this.swiperSlides.length + 1) &#125; &#125;, 3000) &#125;, components:&#123; swiper, swiperSlide &#125; &#125;&lt;/script&gt; Vue-Awesome-Swiper 插件 swiper官网中的API配置均可使用","categories":[],"tags":[]},{"title":"搭建Vuemint-ui 框架","slug":"vuemint-ui","date":"2018-05-15T09:09:03.908Z","updated":"2018-05-15T10:01:18.755Z","comments":true,"path":"2018/05/15/vuemint-ui/","link":"","permalink":"http://yoursite.com/2018/05/15/vuemint-ui/","excerpt":"","text":"mint-ui 是有饿了么前端团队推出的基于Vue.js的移动端组件库。下面就让我们一起来看看mint-ui的构建吧。 安装vue.js环境12// 全局安装脚手架npm install -g vue-cli 创建vue项目1234567// 创建一个基于 webpack 模板的新项目 vue init webpack my-prj// 安装依赖 cd my-project npm install// 安装路由 npm install vue-router 下载、引用Mint-ui12345npm install mint-ui -S// 引入全部组件 在main.js中引用import Mint from &apos;mint-ui&apos;Vue.use(Mint) 每个组件的使用方法请阅读文档，这里只举一个微小的例子。在 app.vue 中 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;template&gt; &lt;h1&gt;mint-uiexample&lt;/h1&gt; &lt;mt-button type=&quot;primary&quot; @click=&quot;sheetVisible = true&quot;&gt; 选择操作 &lt;/mt-button&gt; &lt;mt-actionsheet cancel-text=&quot;&quot; :actions=&quot;actions&quot; :visible.sync=&quot;sheetVisible&quot;&gt; &lt;/mt-actionsheet&gt;&lt;/template&gt;&lt;script&gt; import &#123; Toast, MessageBox &#125; from &apos;mint-ui&apos;; export default &#123; name: &apos;app&apos;, data() &#123; return &#123; sheetVisible: false, actions: [&#123; name: &apos;展示 Toast&apos;, method: this.showToast &#125;, &#123; name: &apos;展示 Message Box&apos;, method: this.showMsgbox &#125;] &#125;; &#125;, methods: &#123; showToast() &#123; Toast(&apos;这是一个 Toast&apos;); &#125;, showMsgbox() &#123; MessageBox(&apos;提示&apos;, &apos;这是一个 Message Box&apos;); &#125; &#125; &#125;;&lt;/script&gt; 效果如下 运行、打包12345// 启动项目 locallhot:8080npm run dev// 打包 生成dist文件夹npm run bulid mint-ui地址 http://mint-ui.github.io/#!/zh-cn","categories":[],"tags":[]},{"title":"js中的Ajax总结","slug":"ajax","date":"2018-04-20T12:08:24.967Z","updated":"2018-04-21T05:18:41.939Z","comments":true,"path":"2018/04/20/ajax/","link":"","permalink":"http://yoursite.com/2018/04/20/ajax/","excerpt":"","text":"一、ajax的作用: 1.就是用js读服务器后台的的数据。 2.无刷新的情况下读取服务器上面的数据,如:验证账号和密码是否正确等。 （一）、ajax的优点：1.减少冗余请求和响应对服务造成的负担。 2.无刷新更新页面,带来更好的用户体验。 3.减轻服务器速写的负担，节约空间和宽带租用成本。 4.采用异步提交,读写速度更快。 （二）、ajax的缺点：1.AJAX大量的使用了javascript和ajax引擎,这些取决于浏览器的支持.在编写的时候考虑对浏览器的兼容性。 AJAX只是局部刷新,所以页面的后退按钮是没有用的。 对流媒体还有移动设备的支持不是太好等。 Get和Post的区别 get方式:常见的表单提交方式:将值在url后面提交;?userName=value&amp;passWord=val。12345&lt;form action=&quot;www.baidu.com&quot; method=&quot;get&quot;&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;userName&quot;&gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 区别: 1.get方式是通过网址进行传递数据的，post是通过http中Content进行传递的。 2.get容量小,不适合传递大数据,(一般4k-10k)，post方式容量相对大很多，一般服务器可以达到2G容量。 3.对于太大的文件，就不会走post，走控件。 4.get方式安全性差，post相对来说会好一点，一帮安全只能走https。 5.get方式是有缓存的,post没有缓存，get更适合向服务器获取数据，post更适合向服务器传递数据。","categories":[],"tags":[]},{"title":"瀑布流照片墙布局","slug":"waterfall","date":"2018-04-16T11:07:27.688Z","updated":"2018-04-16T13:03:06.686Z","comments":true,"path":"2018/04/16/waterfall/","link":"","permalink":"http://yoursite.com/2018/04/16/waterfall/","excerpt":"","text":"瀑布流概念 瀑布流布局是错落式的布局方式。它有一个特点，整个布局以列为单位，下一个区块总是放在总高度最短的那一列的下面。 实现 html代码块 123456&lt;ul id=&quot;pics&quot;&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; css代码块 12345*&#123;margin:0;padding:0&#125;;#pics&#123;list-style: none;margin: 30px auto;width: 1080px;&#125;#pics li&#123;float: left;width: 250px;margin: 10px;&#125;#pics li div&#123;width: 210px;padding: 10px;border: 1px solid gray;margin-bottom: 20px;&#125;#pics li div img&#123;width: 200px;&#125; js代码块 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//运用ajax获取图片地址//获取页面元素(组件/控件)let lis=document.getElementById(&quot;pics&quot;).getElementsByTagName(&quot;li&quot;);//接收服务器数据function fn(data)&#123; //遍历所有数据 for(let i in data)&#123; let oDiv=document.createElement(&quot;div&quot;); let oImg=document.createElement(&quot;img&quot;); let oP=document.createElement(&quot;p&quot;); //将接收的数据放到页面组件中 oImg.src=data[i].preview; //缩略图 oP.innerHTML=data[i].title; //标题 //将oImg和oP放到oDiv中 oDiv.appendChild(oImg); oDiv.appendChild(oP); //按一定的规律将图片放入到li中 switch(i%4)&#123; case 0: lis[0].appendChild(oDiv); break; case 1: lis[1].appendChild(oDiv); break; case 2: lis[2].appendChild(oDiv); break; case 3: lis[3].appendChild(oDiv); break; default: lis[0].appendChild(oDiv); break; &#125; &#125; &#125;//pageIndex表示页码let pageIndex=1;let JSONP=document.creatElement(&quot;script&quot;);JSONP.type=&apos;text/javaScript&apos;;//src表示地址 fn表示回调函数JSONP.src=&quot;http://www.wookmark.com/api/json/popular?page=&apos;+pageIndex+&apos;&amp;callback=fn&quot;;document.body.appendChild(JSONP); 这种方式实现的效果是每个列的元素内的图片数量是一致的，如果某一列高度图片过高，那么就会出现最后的效果是参差不齐的。如果在加载下一页，效果就会更加不好，会存在一个又一个的窟窿，这显然是和我们想要的效果是不一致的。那样这就需要我们队代码进行一定的更改。代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//获取页面元素(组件/控件)let lis=document.getElementById(&quot;pics&quot;).getElementsByTagName(&quot;li&quot;);//pageIndex表示页码let pageIndex=1;let isLoaded=false;loadData();//加载数据//滚动事件window.onscroll=function()&#123; var index=getMinHeight();//最短列的索引 // console.log(document.documentElement.scrollTop);//滚动距离 //滚动高度 var h1=document.documentElement.scrollTop; var h2=document.documentElement.clientHeight;//视口高度 var h3=lis[index].offsetHeight;//最短列高度 if(h1+h2&gt;h3)&#123; //加载下一页 pageIndex++; if(isLoaded)&#123; loadData(); &#125; &#125;&#125;;//接收服务器数据function fn(data)&#123; //遍历所有数据 for(let i in data)&#123; let oDiv=document.createElement(&quot;div&quot;); let oImg=document.createElement(&quot;img&quot;); let oP=document.createElement(&quot;p&quot;); //将接收的数据放到页面组件中 oImg.src=data[i].preview; //缩略图preview表图片路径 oP.innerHTML=data[i].title; //标题title表图片标题 //将oImg和oP放到oDiv中 oDiv.appendChild(oImg); oDiv.appendChild(oP); //设置div预留高度 var oH=(data[i].height/data[i].width)*220+80+&apos;px&apos;; oDiv.style.height=oH; oDiv.appendChild(oImg); oDiv.appendChild(oP); //计算 上一次存放后，所有列中最短列 //将图片放置在最短的列中 var index=getMinHeight(); lis[index].appendChild(oDiv); &#125; isLoaded=true;//加载完毕 &#125;;//获取最短列function getMinHeight()&#123; let minIndex=0; //假设第一列最短 最短列索引 //取出最短列的高度 let mHieght=lis[minIndex].offsetHeight; for(let i=0;i&lt;lis.length;i++)&#123; if(lis[i].offsetHeight&lt;mHieght)&#123; mHieght=lis[i].offsetHeight; //将高度短的列的高度保存起来 minIndex=i; //将短的列的索引保存起来 &#125; &#125; return minIndex;&#125;;function loadData()&#123; isLoaded=false;//正在加载 let JSONP=document.creatElement(&quot;script&quot;); JSONP.type=&apos;text/javaScript&apos;; //src表示地址大家可以自行添加 fn表示回调函数 JSONP.src=&quot;http://----?page=&apos;+pageIndex+&apos;&amp;callback=fn&quot;; document.body.appendChild(JSONP);&#125; 最后还需要提醒大家一点，本篇文章中的例子仅供参考学习，是用于帮助大家理解瀑布流布局的，切误将本篇文章中的代码直接使用在正式项目当中。希望以上代码对大家有所帮助。","categories":[],"tags":[]},{"title":"事件流","slug":"floa","date":"2018-04-12T10:45:12.115Z","updated":"2018-04-16T11:10:12.457Z","comments":true,"path":"2018/04/12/floa/","link":"","permalink":"http://yoursite.com/2018/04/12/floa/","excerpt":"","text":"JS事件流最早要从IE和网景公司的浏览器大战说起，IE提出的是冒泡流，而网景提出的是捕获流，后来在W3C组织的统一之下，JS支持了冒泡流和捕获流，但是目前低版本的IE浏览器还是只能支持冒泡流(IE6,IE7,IE8均只支持冒泡流)，所以为了能够兼容更多的浏览器，建议大家使用冒泡流。 事件作用范围12345678910111213141516171819202122232425262728293031323334353637383940414243//css&lt;style type=&quot;text/css&quot;&gt; #wrap &#123; width: 200px; height: 200px; background: orange; &#125; #content &#123; position: relative; top: 50px; left: 50px; width: 100px; height: 100px; background: #eeddff; &#125; #inner &#123; position: relative; top: 25px; left:25px; width: 50px; height: 50px; background: #44ddff; &#125;&lt;/style&gt;//html&lt;div id=&quot;wrap&quot;&gt; &lt;div id=&quot;content&quot;&gt; &lt;div id=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;//js&lt;script&gt; var wrap = document.getElementById(&apos;wrap&apos;); wrap.addEventListener(&apos;click&apos;,function()&#123; alert(&apos;789&apos;); &#125;,false);&lt;/script&gt;//当点击warp块(包括被子元素的部分)任何一部分时，都会弹出789。这是相当于3个click作用在其上。 试验css html同上，1234567891011121314//scriptvar wrap = document.getElementById(&apos;wrap&apos;);var content = document.getElementById(&apos;content&apos;);var inner = document.getElementById(&apos;inner&apos;);wrap.addEventListener(&apos;click&apos;,function()&#123; alert(&apos;789&apos;);&#125;,false);content.addEventListener(&apos;click&apos;,function()&#123; alert(&apos;456&apos;);&#125;,false);inner.addEventListener(&apos;click&apos;,function()&#123; alert(&apos;123&apos;);&#125;,false); 这样执行的话，就会先弹出123，然后弹出456，最后弹出789。 DOM事件流css html 同上12345678910111213141516171819202122var wrap = document.getElementById(&apos;wrap&apos;);var content = document.getElementById(&apos;content&apos;);var inner = document.getElementById(&apos;inner&apos;);wrap.addEventListener(&apos;click&apos;,function()&#123; alert(&apos;wrap&apos;);&#125;,true);content.addEventListener(&apos;click&apos;,function()&#123; alert(&apos;content&apos;);&#125;,true);inner.addEventListener(&apos;click&apos;,function()&#123; alert(&apos;inner&apos;);&#125;,true);wrap.addEventListener(&apos;click&apos;,function()&#123; alert(&apos;wrap11&apos;);&#125;,false);content.addEventListener(&apos;click&apos;,function()&#123; alert(&apos;content11&apos;);&#125;,false);inner.addEventListener(&apos;click&apos;,function()&#123; alert(&apos;inner11&apos;);&#125;,false); 这样点击中心执行 会先弹出wrap 在弹出content 后弹出inner 然后弹出inner11，content11，wrap11。按上面的例子为，先调用冒泡阶段的事件处理程序，再调用捕获阶段的事件处理程序。","categories":[],"tags":[]},{"title":"半小时掌握正则表达式","slug":"reg","date":"2018-04-11T11:49:44.175Z","updated":"2018-04-11T13:26:54.827Z","comments":true,"path":"2018/04/11/reg/","link":"","permalink":"http://yoursite.com/2018/04/11/reg/","excerpt":"","text":"正则表达几个正则表达式编辑器 Debuggex ：https://www.debuggex.com/ PyRegex：http://www.pyregex.com/ Regexper：http://www.regexper.com/ 正则表达式 正则表达式是一种特殊的字符串模式，用于匹配一组字符串，就是定义一种规则去匹配符合规则的字符。 正则表达式符号 匹配符 1234567. //匹配除换行符 \\n 之外的任何单字符。\\d //匹配一个数字。等价于[0-9]。\\D //匹配一个非数字。等价于[^0-9]。\\w //匹配数字、字母、下划线。等价于[0-9a-zA-Z_]。\\W //匹配非字母、数字、下划线。等价于 &apos;[^A-Za-z0-9_]&apos;。\\s //匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。\\S //匹配任何非空白字符。等价于[^ \\f\\n\\r\\t\\v]。 选择符 123| //指明两项之间的一个选择。[] //字符集() //捕捉组 匹配符定位符 123456 /g //全局匹配 /i // 忽略大小写 /m //多行匹配^ //匹配输入字符串开始的位置。$ //匹配输入字符串结尾的位置。 案例：p=/^[A-Za-z]+$/ //匹配由26个英文字母组成的字符串p=/^[1-9]\\d*$/ //匹配整数p=/^\\w+@+\\w+[.]+\\w$/ //匹配邮箱格式p=/^[\\u2E80-\\u9FFF]+$/ //Unicode编码中的汉字范围 用正则替换字符串中的空格 var p=/\\s/g;var str=”a sffs dfj hsdf”var str1=str.replace(p,”0”);console.log(str1); //a0sffs0dfj0hsdf 通过这个简单例子，相信大家对正则表达式有了更进一步的理解，祝大家学习愉快！","categories":[],"tags":[]},{"title":"技术分享篇","slug":"proto","date":"2018-04-10T11:33:43.923Z","updated":"2018-04-10T13:30:49.639Z","comments":true,"path":"2018/04/10/proto/","link":"","permalink":"http://yoursite.com/2018/04/10/proto/","excerpt":"","text":"Welcome 原型链原型对象在Javascript中，万物皆对象，但对象也有区别，大致可以分为两类，即：普通对象 Object 和 函数对象 Function。 一般通过 new Function 产生的对象是函数对象，其他对象都是普通对象。 所有的对象都有（proto）属性 只有函数对象有（prototype）属性 函数对象12345678function fn()&#123;&#125;;var fn1=function()&#123;&#125;;console.log(typeof fn); //function console.log(typeof fn1); //function console.log(typeof Object); //function console.log(typeof Array); //function console.log(typeof Date); //function ...... 原型对象其实就是构造函数的一个实例对象，例如人对象，相当于在person创建的时候，自动创建了一个它的实例，并且把这个实例赋值给了prototype。123function Person()&#123;&#125;; let temp = new Person(); Person.prototype = temp; 原型链原型链是实现继承的主要方法 原型链的思路：利用原型让一个引用类型继承另一个引用类型的属性和方法。 JS通过原型链实现继承列子： 1234567891011121314151617181920212223//定义一个 Animal 构造函数function Animal()&#123; this.type = &apos;Animal&apos;; &#125;//给 Animal 定义方法Animal.prototype.speack = function()&#123; console.log(this.type);&#125; // 定义一个 Dog 对象function Dog(name)&#123; this.name = name; this.type = &apos;汪汪汪&apos;;&#125;//改变 Dog 的 prototype 指针，指向一个 Animal 实例Dog.prototype = new Animal();Dog.prototype.speak = function () &#123; console.log(this.name+this.type+&quot;叫&quot;);&#125;var dog = new Dog(&apos;小黄&apos;);dog.speak(); //Animal //输出 小黄汪汪汪叫。 这就说明，我们可以通过原型链的方式，实现 Dog 继承 Animal 的所有属性和方法。 总结来说： Dog.prototype 指向的原型对象后，实例的内部指针也发生了改变，指向了新的原型对象，然后就能实现类与类之间的继承了。（但是如果在重写原型对象之前，产生的实例，其内部指针指向的还是最初的原型对象。）","categories":[],"tags":[]},{"title":"技术分享篇","slug":"closure","date":"2018-04-09T09:03:05.965Z","updated":"2018-04-09T13:05:03.790Z","comments":true,"path":"2018/04/09/closure/","link":"","permalink":"http://yoursite.com/2018/04/09/closure/","excerpt":"","text":"Welcome to 刘沅 blog! 闭包现象1.什么是闭包 闭包是就是函数中的函数，里面的函数可以访问外面函数的变量，外面的变量的是这个内部函数的一部分。 2.变量作用域 要理解闭包，首先要了解JavaScript的变量作用域 变量的作用域有两种：全局变量、局部变量 全局变量：变量定义在函数外面，在函数内可以调用 局部变量：变量定义在函数内，在函数外不能调用 3.闭包1234567891011121314// 例： $ &lt;script type=&quot;text/javascript&quot;&gt;$ function demo()&#123; var num=1; function demo1()&#123; var num1=2; console.log(num); //true &#125; //console.log(num1); error &#125; demo();$ &lt;/ script&gt; &lt;-- 这里的函数demo1()和变量num1就形成了一个闭包 --&gt; 4.常见陷阱12345678910111213function createFunction()&#123;var result=[];for(var i=0;i&lt;10;i++)&#123; result[i]=function()&#123; return i; &#125;&#125;result result;&#125;var a=createFunction();for(var i=0;i&lt;a.length;i++)&#123; console.log(a[i]());&#125; 咋一看输出的是0~9，但实际上市输出的是10个9。这就是陷阱 像a=function(){alert(‘你好’);}是不会弹出窗口的，只有家加上a();才可以执行代码。 解决方案 112345678910111213function createFunction()&#123; var result=[]; for(var i=0;i&lt;10;i++)&#123; (function(j)&#123; console.log(j); &#125;)(i) &#125; return result;&#125; var a=createFunction(); for(var i=0;i&lt;a.length;i++)&#123; console.log(a[i]()); &#125; 这样就输出了0~9 十个数。 解决方案 2123456789101112131415function createFunction()&#123; var result=[]; for(var i=0;i&lt;10;i++)&#123; result[i]=(function(j)&#123; //原理和上面一种方法一样的，所以可以实现闭包 return function()&#123; //在这个闭包里面再写一个匿名函数 return j &#125; &#125;)(i) &#125; return result;&#125; var a=createFunction(); for(var i=0;i&lt;a.length;i++)&#123; console.log(a[i]()); &#125; 输出结果和方案1 一致。 解决方案 312345678910111213function createFunction()&#123; var result=[]; for(var i=0;i&lt;10;i++)&#123; result[i]=function(j)&#123; //原理和上面一种方法一样的，所以可以实现闭包 return j; //这样把匿名函数自我执行的时候赋值给一个变量，那么圆括号是可以去掉的 &#125;(i); &#125; return result; &#125; var a=createFunction(); for(var i=0;i&lt;a.length;i++)&#123; console.log(a[i]); &#125; 匿名函数在执行的时候他本身就传递给了一个变量result[i]，所以匿名函数的圆括号是可以去掉的 以上就是几种解决闭包一些的办法，当然还有更多办法。大家可以选择更多的资料加深印象。 以上就是本文的全部内容，希望对大家的学习有所帮助。","categories":[],"tags":[]},{"title":"技术分享篇","slug":"blog","date":"2018-04-08T08:32:56.834Z","updated":"2018-04-09T08:05:24.464Z","comments":true,"path":"2018/04/08/blog/","link":"","permalink":"http://yoursite.com/2018/04/08/blog/","excerpt":"","text":"Welcome to 刘沅 blog! 博客创建1.安装前提Hexo 是基于Node.js的一个博客框架，安装Hexo的前提需要安装Node.js。 2.安装 node.js node.js是运行环境，这个运行环境是运行js代码的（运行环境–&gt;浏览器）。 在网络上搜索node.js中文网选择下载，找到自己电脑版本下载安装（傻瓜式安装–&gt;一直按下一步）。 按Window+R打开命令提示窗，按 node -v , npm -v按确认键来进行验证node.js是否安装成功。3.安装Hexo工具 在当前环境下按 npm install -g hexo-cli //安装hexo工具（如果速度过慢 可以按ctrl+c终止，切换安装源 npm config set registry https://registry.npm.taobao.org 淘宝安装镜像文件可以加速下载）。 4.安装博客源代码12345//在你的磁盘中创建一个文件夹（路径内不含中文）$ hexo init blog //找到这个的文件夹 按shift+鼠标右键选择 在此处打开Powershell窗口 输入此命令。$ cd blog //切换到当前blog文件夹中$ nmp install //安装依赖文件$ hexo server //在本地开启服务器 5.创建github库 输入网址打开http://www.github.com,创建一个账户 选择 New repository 创建一个新库命名方式为 用户的名称+.github.io6.安装git插件并配置远程仓库123456$ npm install hexo-deployer-git --save //开启服务器后安装插件// 在hexo的项目中，根目录中找到 [_config.yml]()文件进行配置$ deploy :$ type : git //注意每个冒号后面要有空格$ respository: git@github.com:lyaaa/lyaaa.github.io.git //github地址在Code下 Clone or download下$ branch: master //主分支 7.将hexo代码放到远程服务器上12$ hexo clean //将之前的生成的public文件夹删掉$ hexo d g //生成html代码并且提交到github上 d 表示提交、 g 表示生成 8.查看博客 本地查看 启动服务器hexo server 在浏览器打开http://localhost:4000 or http://127.0.0.1:4000/ 远程查看 打开github找到当前文件位置，选择Settings下拉找到 GitHub Pages 复制链接 https://lyaaa.github.io/ 打开查看9.博客界面优化 在github主页中搜索hexo 主题 选择一个主题打开 在服务器上下载安装包 如 git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 修改配置 找到hexo根目录下的 _config.yml 下的 theme:修改为 yilia 。 骚年去安装属于你自己的博客吧!!!","categories":[],"tags":[]}]}